# 定时器

###  **核心文件角色**

| 文件                                                         | 用途         | 关键内容                                                     |
| ------------------------------------------------------------ | ------------ | ------------------------------------------------------------ |
| **[general_timer.h](vscode-file://vscode-app/c:/Users/12804/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)** | 定时器头文件 | [GeneralTimer](vscode-file://vscode-app/c:/Users/12804/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 类定义、[TimerEvent](vscode-file://vscode-app/c:/Users/12804/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 结构体 |
| **[general_timer.cc](vscode-file://vscode-app/c:/Users/12804/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)** | 定时器实现   | 构造函数、事件添加、硬件定时器回调                           |
| **[application.h](vscode-file://vscode-app/c:/Users/12804/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)** | 应用头文件   | [GeneralTimer *general_timer_](vscode-file://vscode-app/c:/Users/12804/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 成员变量 |
| **[application.cc](vscode-file://vscode-app/c:/Users/12804/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)** | 应用实现     | 定时器初始化和管理                                           |
| **mcp_server.cc**                                            | MCP服务器    | `self.add_timer_event` 工具实现                              |

```c++
用户请求: "在10秒后提醒我喝水"
  ↓
MCP Server 调用: AddTimerEvent(
    GENERAL_TIMER_MESSAGE, 
    10,                    // 延迟10秒
    "喝水提醒"
)
  ↓
GeneralTimer::AddTimerEvent()
  - 找到空闲槽位（0-9）
  - 设置触发时间 = 当前时间 + 10
  - 更新 next_time_ = 最早的触发时间
  ↓
10秒后，硬件定时器触发
  ↓
timer_deal_func() 被调用
  - 检查是否到达最早事件时间
  - 遍历所有事件
  - 找到"喝水提醒"事件 → printf输出
  ↓
事件执行完成，标记为未使用
```



## general_timer.h

#### 定时器事件结构体,类

```c++
#ifndef GENERAL_TIMER_H
#define GENERAL_TIMER_H

#include <string>
#include <mutex>
#include "time.h"
#include <esp_timer.h>
#define GENERAL_TIMER_MAX_EVENTS 10
#define GENERAL_TIMER_MESSAGE 1
#define GENERAL_TIMER_FUNCTION 0

typedef struct 
{
    bool used;//是否被添加事件
    bool type;//是message 还是 function
    time_t time; // s, 定时器到达的时间点
    // message when type==true, or function callback when type==false
    std::string message;
    void (*func)(void*);
    void *arg;
}TimerEvent;

//创建一个类 GeneralTimer
class GeneralTimer {
public:
    GeneralTimer();//构造函数，初始化定时器
    ~GeneralTimer();//析构函数，清理资源

    bool AddTimerEvent(bool type, int time_to_deal, const std::string& message, void (*func)(void*) = nullptr, void *arg = nullptr);
    time_t GetNextTime() const { return next_time_; }
private:
    time_t next_time_;
    esp_timer_handle_t clock_timer_handle_ = nullptr;
    // time_t time_;
    std::mutex mutex_;
};

#endif

```

## general_timer.cc

#### GeneralTimer 类的实现:

#### 构造函数和析构函数，以及 AddTimerEvent 方法

##### 构造函数

```c++
GeneralTimer::GeneralTimer(void) {
    // time_ = time(NULL)
    esp_timer_create_args_t clock_timer_args = {
        .callback = timer_deal_func,
        .arg = this,
        .dispatch_method = ESP_TIMER_TASK,
        .name = "GeneralTimer",
        .skip_unhandled_events = true
    };
    esp_timer_create(&clock_timer_args, &clock_timer_handle_);
    esp_timer_start_periodic(clock_timer_handle_, 1000000); // 1s

}
```

##### 构造函数

```c++
GeneralTimer::~GeneralTimer(void) {
    if (clock_timer_handle_ != nullptr) {
        esp_timer_stop(clock_timer_handle_);
        esp_timer_delete(clock_timer_handle_);
    }
}
```

##### AddTimerEvent 

遍历定时器事件数组，找到第一个未使用的槽位

标记为已使用，填充所有事件信息

计算触发时间：当前时间 + 延迟时间

```c++
bool GeneralTimer::AddTimerEvent(bool type, int time_to_deal, const std::string& message, void (*func)(void*), void *arg){
    std::lock_guard<std::mutex> lock(mutex_);
    time_t time_ = time(NULL);
    int i;
    
    //遍历定时器事件数组，找到第一个未使用的槽位
    //标记为已使用，填充所有事件信息
    //计算触发时间：当前时间 + 延迟时间
    for(i=0;i<GENERAL_TIMER_MAX_EVENTS;i++){
        if(!timer_events[i].used){
            timer_events[i].used = true;
           timer_events[i].type = type;
            timer_events[i].time = time_ + time_to_deal;
            timer_events[i].message = message;
            timer_events[i].func = func;
            timer_events[i].arg = arg;
            break;
        }
    }
    if(i==GENERAL_TIMER_MAX_EVENTS){
        //没有空闲槽位，添加失败
        return false;
    }
    time_t temp = timer_events[i].time;

    for(i=0;i<GENERAL_TIMER_MAX_EVENTS;i++){
        if(timer_events[i].time<temp && timer_events[i].used){
            temp = timer_events[i].time;
        }
    }
    next_time_ = temp;

    return true;

}
```

##### timer_deal_func

```
硬件定时器每秒触发
    ↓
获取当前时间 + 获取下一个事件时间
    ↓
是否到达下一事件时间？
    ├─ 否 → 直接返回（优化）
    └─ 是 → 遍历所有事件
        ↓
    对每个已使用的事件检查
        ↓
    时间是否到达？
        ├─ 否 → 继续检查下一个
        └─ 是 → 执行事件（打印或回调）
            ↓
        清理槽位（标记为未使用）
```



```c++
void timer_deal_func(void* arg){
    GeneralTimer* timer = (GeneralTimer*)arg;
    time_t current_time = time(NULL);
    if(current_time < timer->GetNextTime()){
        return;
    }

    for(int i=0;i<GENERAL_TIMER_MAX_EVENTS;i++){
        if(timer_events[i].used){
            if(current_time >= timer_events[i].time){
                // deal event
                if(timer_events[i].type){
                    // type==true, print message
                    printf("Timer Event: %s\n", timer_events[i].message.c_str());
                }else{
                    // type==false, call function callback
                    if(timer_events[i].func != nullptr){
                        timer_events[i].func(timer_events[i].arg);
                    }
                }
                // mark event as unused
                timer_events[i].used = false;
            }
        }
    }
}
```

## application.h

```c++
#include "qin_custom/general_timer.h"


public:
GeneralTimer *general_timer_ = nullptr;
```

## application.cc

```c++
void Application::Start() {
	general_timer_ = new GeneralTimer();
	const std::string timer_str =  "Application::OnGeneralTimerMessage";
}
```

## mcp_server.cc

```c++
AddTool("self.add_timer_event", 
        "Add a timer event that will trigger after a specified time. seconds\n",
        PropertyList({
            Property("seconds", kPropertyTypeInteger),
            Property("message", kPropertyTypeString)

        }), 
        [](const PropertyList& properties) -> ReturnValue {
            int time_seconds = properties["seconds"].value<int>();
            std::string message_ = properties["message"].value<std::string>();
            
            auto& app = Application::GetInstance();
            if (app.general_timer_ != nullptr) {
                app.general_timer_->AddTimerEvent(GENERAL_TIMER_MESSAGE, time_seconds, message_);
            }
            return true;
        });
```

