# YOLOv5 模型结构与构建原理

### 一、模型结构的定义位置与核心文件

YOLOv5 模型结构并非硬编码在业务逻辑中，而是统一配置在项目的 `models` 文件夹下的 YAML 文件中，不同模型（S/M/L/X）对应不同配置文件，结构逻辑一致，仅参数存在差异。

#### 1. 核心文件说明

- `models/yolov5s.yaml`（以 S 模型为例）：存储模型核心结构配置，包括类别数、缩放系数、锚框、主干网络（backbone）、头部结构（head）等关键信息。

- `models/yolo.py`：模型构建核心逻辑，负责解析 YAML 配置并实例化网络模块。

- `models/commons.py`：定义网络基础模块（如 Conv、C3、SPPF 等），供 YAML 配置调用。

#### 2. YAML 配置文件核心内容解析（yolov5s.yaml）

```yaml
# YOLOv5s 模型配置文件 (假设输入为640x640)
# 从原文提取的核心配置（无修改）
nc: 80  # 目标类别数，默认80（COCO数据集）
depth_multiple: 0.33  # 深度缩放系数（控制模块重复次数）
width_multiple: 0.50  # 宽度缩放系数（控制通道数）
anchors:  # 锚框，3个特征图各3组锚框
  - [10,13, 16,30, 33,23]
  - [30,61, 62,45, 59,119]
  - [116,90, 156,198, 373,326]

# 主干网络（backbone）- 特征提取部分
backbone:
  # [从哪层输入, 重复次数, 模块类型, [参数]]
  [[-1, 1, Conv, [64, 6, 2, 2]],  # 第0层: Conv, 输出 1*64*320*320 (640/2=320)
   [-1, 1, Conv, [128, 3, 2]],    # 第1层: Conv, 输出 1*128*160*160 (320/2=160)
   [-1, 3, C3, [128]],            # 第2层: C3, 输出 1*128*160*160 (尺寸不变)
   [-1, 1, Conv, [256, 3, 2]],    # 第3层: Conv, 输出 1*256*80*80 (160/2=80)
   [-1, 6, C3, [256]],            # 第4层: C3, 输出 1*256*80*80 (尺寸不变)
   [-1, 1, Conv, [512, 3, 2]],    # 第5层: Conv, 输出 1*512*40*40 (80/2=40)
   [-1, 9, C3, [512]],            # 第6层: C3, 输出 1*512*40*40 (尺寸不变)
   [-1, 1, Conv, [1024, 3, 2]],   # 第7层: Conv, 输出 1*1024*20*20 (40/2=20)
   [-1, 3, C3, [1024]],           # 第8层: C3, 输出 1*1024*20*20 (尺寸不变)
   [-1, 1, SPPF, [1024, 5]],      # 第9层: SPPF, 输出 1*1024*20*20 (尺寸不变)
  ]

# 头部结构（head）- 多尺度特征融合和检测部分
head:
  [[-1, 1, Conv, [512, 1, 1]],    # 第10层: Conv(1x1), 输出 1*512*20*20 (尺寸不变)
   [-1, 1, nn.Upsample, [None, 2, 'nearest']],  # 第11层: 上采样2倍, 输出 1*512*40*40
   [[-1, 6], 1, Concat, [1]],     # 第12层: 拼接第11层和第6层, 输出 1*1024*40*40
   [-1, 3, C3, [512, False]],     # 第13层: C3, 输出 1*512*40*40 (尺寸不变)
   [-1, 1, Conv, [256, 1, 1]],    # 第14层: Conv(1x1), 输出 1*256*40*40 (尺寸不变)
   [-1, 1, nn.Upsample, [None, 2, 'nearest']],  # 第15层: 上采样2倍, 输出 1*256*80*80
   [[-1, 4], 1, Concat, [1]],     # 第16层: 拼接第15层和第4层, 输出 1*512*80*80
   [-1, 3, C3, [256, False]],     # 第17层: C3, 输出 1*256*80*80 (尺寸不变)
   [-1, 1, Conv, [256, 3, 2]],    # 第18层: Conv(3x3,stride=2), 输出 1*256*40*40 (80/2=40)
   [[-1, 14], 1, Concat, [1]],    # 第19层: 拼接第18层和第14层, 输出 1*512*40*40
   [-1, 3, C3, [512, False]],     # 第20层: C3, 输出 1*512*40*40 (尺寸不变)
   [-1, 1, Conv, [512, 3, 2]],    # 第21层: Conv(3x3,stride=2), 输出 1*512*20*20 (40/2=20)
   [[-1, 10], 1, Concat, [1]],    # 第22层: 拼接第21层和第10层, 输出 1*1024*20*20
   [-1, 3, C3, [1024, False]],    # 第23层: C3, 输出 1*1024*20*20 (尺寸不变)
   [[17, 20, 23], 1, Detect, [nc, anchors]],  # 第24层: Detect, 输入3个尺度的特征图
  ]
```

#### 3. 配置参数核心含义

- **nc**：目标类别数，默认 80（适配 COCO 数据集），自定义数据集需修改为对应类别数。

- **depth_multiple/width_multiple**：深度/宽度缩放系数，分别控制模块重复次数和通道数，决定模型规模（S/M/L/X 模型差异核心）。

- **anchors**：锚框预设值，3 组特征图各对应 3 组锚框，适配不同尺寸目标检测。

- **backbone/head**：网络核心部分，每一行配置格式为 `[from, number, module, args]`，含义如下：
  - from：当前层输入来源，`-1` 表示来自上一层，具体数字表示来自对应层编号（如 6 表示第 6 层输出）。

    - number：模块重复次数，仅 C3 模块可能大于 1，其他模块默认 1。

    - module：使用的网络模块（如 Conv、C3、SPPF、Concat、Detect 等）。

    - args：模块参数（如 Conv 模块参数为 [输出通道、卷积核大小、步长、padding(填充数)]）。

### 二、用 TensorBoard 可视化模型结构（实操方法）

网络结构可通过 TensorBoard 直观展示，无需手动绘图，同时支持监控训练参数，操作步骤如下：

#### 1. 启动 TensorBoard

```Bash
# 1. 激活 yolov5 虚拟环境（终端前缀显示 (yolov5)）
# 2. 进入 YOLOv5 项目根目录
cd yolov5-master
# 3. 启动 TensorBoard，指定日志目录为 runs
tensorboard --logdir runs
```

#### 2. 查看网络结构

1. 终端输出链接（默认 `http://localhost:6006`），浏览器打开该链接。

2. 点击左侧「Graphs」选项卡，即可看到模型整体结构（输入→DetectionModel→输出）。

3. 交互操作：双击「DetectionModel」展开完整网络；鼠标滚轮缩放、拖拽平移视图；双击模块可查看层级细节。

### 三、网络结构数据流与特征变换规律

通过 TensorBoard 可视化可清晰梳理数据流，核心规律如下：

#### 1. 输入与主干网络特征变换

- 输入图像尺寸为`1×3×640×640`（batch_size=1，3 通道，分辨率 640×640）。

- 主干网络通过连续卷积层执行下采样，每次卷积步长为 2 时，特征图尺寸减半，通道数按宽度系数缩放：
  
  - 第 0 层 Conv：输入 `1×3×640×640` → 输出 `1×32×320×320`（64×0.5=32，尺寸/2）。
    
  - 依次经过卷积、C3 模块，特征图尺寸逐步缩减为 160×160、80×80、40×40、20×20，通道数逐步增加。
    
  - SPPF 模块（第 9 层）为骨干网络最后一层，输出特征图尺寸 `1×1024×20×20`。

#### 2. 头部结构特征融合与检测层

- 头部结构通过「上采样+拼接」实现多尺度特征融合：
  
    - 第 10 层 Conv 降维后上采样（20×20→40×40），与第 6 层输出（40×40）拼接，增强中尺度特征。
    
    - 再次上采样（40×40→80×80），与第 4 层输出（80×80）拼接，增强小尺度特征。
    
    - 通过卷积下采样恢复尺寸，多次拼接后形成 3 个尺度特征图，用于不同尺寸目标检测。
    
- 检测层（Detect）融合 3 个特征图：
  
  - 第 17 层（80×80，8 倍下采样）：检测小目标。
    
  - 第 20 层（40×40，16 倍下采样）：检测中目标。
    
  - 第 23 层（20×20，32 倍下采样）：检测大目标。

### 四、深度与宽度系数的作用机制

depth_multiple（深度系数）和 width_multiple（宽度系数）是控制模型规模的核心参数，直接影响模块重复次数和通道数：

#### 1. 深度系数（depth_multiple）

- 作用：控制 C3 模块的重复次数，公式为 `实际重复次数 = max(round(number×depth_multiple), 1)`。

- 示例（yolov5s.yaml，depth_multiple=0.33）：

    - backbone 中第 2 层 C3：number=3 → 3×0.33≈1 → 实际重复 1 次。

    - backbone 中第 4 层 C3：number=6 → 6×0.33≈2 → 实际重复 2 次。

    - 取最大值 1 是为了保证模块至少存在 1 层，避免网络结构缺失。

#### 2. 宽度系数（width_multiple）

- 作用：控制所有模块的输出通道数，公式为 `实际通道数 = round(args[0]×width_multiple)`。

- 示例（yolov5s.yaml，width_multiple=0.5）：

    - 第 0 层 Conv：args[0]=64 → 64×0.5=32 → 实际输出通道 32。

    - 第 1 层 Conv：args[0]=128 → 128×0.5=64 → 实际输出通道 64。

### 五、模型构建代码逻辑解析（models/yolo.py）

模型构建核心是解析 YAML 配置并实例化模块，关键代码逻辑从原文提取，步骤如下：

#### 1. 配置解析与参数初始化

```Python

# 核心代码逻辑（从原文提取，无修改）
def parse_model(d, ch):  # d=YAML配置字典，ch=输入通道数（初始为3）
    nc, anchors = d.get('nc', 80), d.get('anchors', 3)
    depth_multiple = d.get('depth_multiple', 1.0)
    width_multiple = d.get('width_multiple', 1.0)
    
    # 计算输出通道数：锚框数×(类别数+5)，5为坐标(x,y,w,h) + object分数
    na = (len(anchors[0]) // 2) if isinstance(anchors, list) else anchors
    no = na * (nc + 5)
    
    layers, save, c2 = [], [], ch[-1]  # layers=网络层列表，save=需保存的层，c2=上一层输出通道数
    for i, (f, n, m, args) in enumerate(d['backbone'] + d['head']):
        m = eval(m) if isinstance(m, str) else m  # 实例化模块（如Conv、C3）
        for j, a in enumerate(args):
            try:
                args[j] = eval(a) if isinstance(a, str) else a  # 解析参数
            except:
                pass
        
        # 处理深度系数：控制模块重复次数
        n = n_ = max(round(n * depth_multiple), 1) if n > 1 else n
        if m in [Conv, C3, C3TR, C3Ghost, C3X]:
            c1, c2 = ch[f], args[0]
            c2 = make_divisible(c2 * width_multiple, 8)  # 通道数按宽度系数缩放，确保可被8整除
            args = [c1, c2, *args[1:]]  # 更新输入/输出通道数
            if m is C3:
                args.insert(2, n)  # 为C3模块插入重复次数参数n
                n = 1  # 重置n，避免重复实例化
        
        # 实例化模块并添加到网络层
        m_ = nn.Sequential(*[m(*args) for _ in range(n)]) if n > 1 else m(*args)
        layers.append(m_)
        save.append(i) if f == -1 else None
        ch.append(c2)
    return nn.Sequential(*layers), sorted(save)
```

#### 2. 关键步骤说明

- 模块实例化：通过`eval(m)` 将 YAML 中的模块名称（如 'Conv'）转换为 Python 实例，依赖 `commons.py` 中定义的模块类。

- 通道数调整：通过 `make_divisible` 确保通道数可被 8 整除，适配 GPU 加速运算。

- 层保存：标记 `from=-1` 的层，供后续特征融合时调用对应层输出。

### 六、实操关键注意事项

1. 配置文件一致性：修改 `nc`（类别数）后，需确保与数据集类别一致，否则训练报错；锚框需根据自定义数据集尺寸调整，提升检测精度。

2. 模块修改规范：自定义模块（如添加 C4）需先在 `commons.py` 中定义，再在 YAML 配置中调用，且名称需与代码中一致，否则无法实例化。

3. 层数编号意义：网络层从 0 开始编号，头部结构拼接时需准确引用对应层编号（如 [ -1, 6 ] 表示拼接上一层与第 6 层），编号错误会导致特征融合失败。

4. 可视化依赖：TensorBoard 需在训练后生成日志文件（存于 runs 目录），若未训练可先运行 `python train.py` 生成日志，再启动可视化。

### 七、整体流程回顾

1. 结构定义：在 `models/yolov5s.yaml` 中配置 backbone、head、参数系数及锚框。

2. 可视化验证：通过 TensorBoard 查看网络结构，确认数据流与特征变换规律。

3. 模型构建：`yolo.py` 解析 YAML 配置，按系数调整模块重复次数与通道数，实例化网络。

4. 自定义优化：修改配置文件（如调整系数、替换模块），或在 `commons.py` 中添加新模块，实现网络结构创新。

核心原则：理解模型构建原理是结构修改与优化的前提，需结合配置文件、代码逻辑与可视化结果，确保每一处修改都符合网络数据流规律。