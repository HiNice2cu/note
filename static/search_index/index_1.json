{"/note/小智笔记/Web.html":{"title":"Web","content":"# Web ## mqtt 例:温度传感器作为客户端连接到 MQTT Broker，并通过发布操作将温度数据发布到一个特定主题（例如 `Temperature`）。MQTT Broker 接收到该消息后会负责将其转发给订阅了相应主题（`Temperature`）的订阅者客户端。 ![image 20251116200014788](https://q 1336166460.cos.ap beijing.myqcloud.com/p/202511162000873.png) mqtt_self.cc mqtt_self.h application.cc application.h #### mqtt_self.h ##### 创建类 ```c++ #ifndef MQTT_SELF_H #define MQTT_SELF_H #include <mqtt.h> #include <memory> class mqtt_self { private: std::unique_ptr<Mqtt> mqtt_; /* data */ public: mqtt_self(/* args */); ~mqtt_self(); }; #endif ``` #### mqtt_self.cc ##### 实现构造函数: ![image 20251116202658417](C:\\Users\\12804\\AppData\\Roaming\\Typora\\typora user images\\image 20251116202658417.png) mqtt_ >Subscribe(\"qin/+\", 2) ![image 20251116202635577](C:\\Users\\12804\\AppData\\Roaming\\Typora\\typora user images\\image 20251116202635577.png) mqtt_ >Connect(\"115.190.41.147\", 1883, \"client_id\", \"\", \"\") ```c++ #include \"mqtt_self.h\" #include \"board.h\" #include <esp_log.h> #define TAG \"MQTT_SELF\" mqtt_self::mqtt_self(/* args */) { auto network Board::GetInstance().GetNetwork(); mqtt_ network >CreateMqtt(1); mqtt_ >SetKeepAlive(90); mqtt_ >OnDisconnected([this]() { ESP_LOGW(TAG, \"MQTT disconnected, scheduling reconnect\"); }); mqtt_ >OnConnected([this]() { ESP_LOGI(TAG, \"MQTT connected\"); if (!mqtt_ >Subscribe(\"qin/+\", 2)) { ESP_LOGE(TAG, \"Failed to subscribe to topic\"); } }); mqtt_ >OnMessage([this](const std::string& topic, const std::string& payload) { ESP_LOGI(TAG, \"Received message on topic %s: %s\", topic.c_str(), payload.c_str()); }); if (!mqtt_ >Connect(\"115.190.41.147\", 1883, \"client_id\", \"\", \"\")) { ESP_LOGE(TAG, \"Failed to connect to endpoint\"); return; } ESP_LOGI(TAG, \"Connected to endpoint\"); } mqtt_self::~mqtt_self() { } ``` #### application.h ```c++ private: mqtt_self* mqtt_client_ nullptr; ``` #### application.cc ```c++ void Application::Start(){ \t... \tmqtt_client_ new mqtt_self(); } ``` ## http #### http_self.h ##### 创建类 ```c++ #ifndef HTTP_SELF_H #define HTTP_SELF_H class http_self { private: /* data */ public: http_self(/* args */); ~http_self(); }; #endif ``` #### http_self.cc 网络模块初始化 HTTP GET 请求 状态码检查 响应长度获取 循环读取数据 JSON 解析 数组元素提取 字段验证 资源清理 析构函数 ```c++ #include \"http_self.h\" #include \"board.h\" #include <esp_log.h> #include \"http.h\" #include \"cJSON.h\" #define TAG \"HTTP_SELF\" http_self::http_self(/* args */) { auto network Board::GetInstance().GetNetwork(); auto http network >CreateHttp(2); if (!http >Open(\"GET\", \"https://www.xvsenfeng.top/shops/shoplists/?boardID 24EC4A0AA884\")) { ESP_LOGE(TAG, \"Failed to open HTTP connection\"); return ; } if (http >GetStatusCode() ! 200) { ESP_LOGE(TAG, \"Failed to get firmware, status code: %d\", http >GetStatusCode()); return ; } size_t content_length http >GetBodyLength(); if (content_length 0) { ESP_LOGE(TAG, \"Failed to get content length\"); return ; } char buffer[600]; size_t total_read 0; while (true) { int ret http >Read(buffer, sizeof(buffer)); if (ret < 0) { ESP_LOGE(TAG, \"Failed to read HTTP data: %s\", esp_err_to_name(ret)); return; } ESP_LOGI(TAG, \"Read %s\", buffer); total_read + ret; buffer[total_read] 0; if(total_read> content_length){ break; } } cJSON* root cJSON_Parse(buffer); if (root nullptr) { ESP_LOGE(TAG, \"Failed to parse json message %s\",buffer); return; } cJSON *item cJSON_GetArrayItem(root, 1); cJSON* type cJSON_GetObjectItem(item, \"id\"); if (!cJSON_IsNumber(type)) { ESP_LOGE(TAG, \"Message type is invalid\"); cJSON_Delete(root); return; } ESP_LOGI(TAG, \"id: %d\", type >valueint); cJSON_Delete(root); http >Close(); } http_self::~http_self() { } ``` #### application.h和application.cc同mqtt"},"/note/小智笔记/index.html":{"title":"","content":"# 小智笔记"},"/note/小智笔记/背光backlight.html":{"title":"背光backlight","content":"# 背光backlight ## backlight.h #### 定义函数与变量 ```c++ public: \tvoid brightness_timer_startup(); void brightness_timer_close(); void brightness_trigger(); protected: \tesp_timer_handle_t transition_timer_2_ nullptr; \tint last_timer_value_ 0; ``` ## backlight.cc #### 初始化定时器 ```c++ Backlight::Backlight() { \tconst esp_timer_create_args_t bl_timer_args { .callback [](void* arg) { auto self static_cast<Backlight*>(arg); self >SetBrightness(0,0); }, .arg this, .dispatch_method ESP_TIMER_TASK, .name \"backlight_timer_2\", .skip_unhandled_events true, }; ESP_ERROR_CHECK(esp_timer_create(&bl_timer_args, &transition_timer_2_)); } ``` #### 开启背光定时器,关闭背光定时器,开启背光(设置亮度) ```c++ void Backlight::brightness_timer_startup(){ esp_timer_start_periodic(transition_timer_2_, 5000 * 1000); } void Backlight::brightness_timer_close(){ esp_timer_stop(transition_timer_2_); } void Backlight::brightness_trigger(){ SetBrightness(last_timer_value_); } ``` #### 记录上次亮度(使得再次亮屏时亮度不会改变) ```c++ void Backlight::RestoreBrightness(){ \tint saved_brightness settings.GetInt(\"brightness\", 75); last_timer_value_ saved_brightness; } void Backlight::SetBrightness(uint8_t brightness, bool permanent){ \t... \t//permanent true 表示“这是用户希望长期保留的亮度设置”；permanent false 表示“临时/过渡性的改变”（比如自动熄屏、动画过渡）。 \tif (permanent) { ... last_timer_value_ brightness; } ... } ``` ## application.cc 状态在空闲状态下需要开启背光定时器(到时间自动熄屏),其他状态要关闭 每一个状态都需要开启背光 ```c++ void Application::SetDeviceState(DeviceState state){ \tauto backlight board.GetBacklight(); \t... } ``` # 拓展:触摸亮屏 ## lichuang_dev_board.cc #### 初始化触摸定时器+添加触摸回调函数: ```c++ esp_timer_handle_t touch_timer_2_ nullptr; void InitializeTouch(){ \tesp_lcd_touch_config_t tp_cfg { \t... \t.process_coordinates touch_process_coordinates, \t} \t \tconst esp_timer_create_args_t touch_timer_args { .callback [](void* arg) { ESP_LOGI(TAG, \"Touch timer callback\"); }, .arg this, .dispatch_method ESP_TIMER_TASK, .name \"touch_timer\", .skip_unhandled_events true, }; ESP_ERROR_CHECK(esp_timer_create(&touch_timer_args, &touch_timer_2_)); } ``` #### 触摸回调函数的实现: 该函数在首次触摸时切换聊天状态，随后触摸在计时器有效期内只会重置计时器而不再次切换，从而实现“进入交互→超时退出”的交互窗口。 ```c++ void touch_process_coordinates(esp_lcd_touch_handle_t tp, uint16_t *x, uint16_t *y, uint16_t *strength, uint8_t *point_num, uint8_t max_point_num){ if(esp_timer_is_active(touch_timer_2_)){ esp_timer_stop(touch_timer_2_); esp_timer_start_once(touch_timer_2_, 60000); } else{ auto& app Application::GetInstance(); app.ToggleChatState(); esp_timer_start_once(touch_timer_2_, 60000); ESP_LOGI(TAG, \"Touch detected, toggling chat state\"); } } ``` ```c++ void Application::ToggleChatState() { auto backlight Board::GetInstance().GetBacklight(); if(backlight nullptr){ return; } if(backlight >brightness() 0){ backlight >brightness_trigger(); backlight >brightness_timer_startup(); return; } ... } ```"},"/note/小智笔记/定时器.html":{"title":"定时器","content":"# 定时器 ### **核心文件角色** 文件 用途 关键内容 **[general_timer.h](vscode file://vscode app/c:/Users/12804/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron browser/workbench/workbench.html)** 定时器头文件 [GeneralTimer](vscode file://vscode app/c:/Users/12804/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron browser/workbench/workbench.html) 类定义、[TimerEvent](vscode file://vscode app/c:/Users/12804/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron browser/workbench/workbench.html) 结构体 **[general_timer.cc](vscode file://vscode app/c:/Users/12804/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron browser/workbench/workbench.html)** 定时器实现 构造函数、事件添加、硬件定时器回调 **[application.h](vscode file://vscode app/c:/Users/12804/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron browser/workbench/workbench.html)** 应用头文件 [GeneralTimer *general_timer_](vscode file://vscode app/c:/Users/12804/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron browser/workbench/workbench.html) 成员变量 **[application.cc](vscode file://vscode app/c:/Users/12804/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron browser/workbench/workbench.html)** 应用实现 定时器初始化和管理 **mcp_server.cc** MCP服务器 `self.add_timer_event` 工具实现 ```c++ 用户请求: \"在10秒后提醒我喝水\" ↓ MCP Server 调用: AddTimerEvent( GENERAL_TIMER_MESSAGE, 10, // 延迟10秒 \"喝水提醒\" ) ↓ GeneralTimer::AddTimerEvent() 找到空闲槽位（0 9） 设置触发时间 当前时间 + 10 更新 next_time_ 最早的触发时间 ↓ 10秒后，硬件定时器触发 ↓ timer_deal_func() 被调用 检查是否到达最早事件时间 遍历所有事件 找到\"喝水提醒\"事件 → printf输出 ↓ 事件执行完成，标记为未使用 ``` ## general_timer.h #### 定时器事件结构体,类 ```c++ #ifndef GENERAL_TIMER_H #define GENERAL_TIMER_H #include <string> #include <mutex> #include \"time.h\" #include <esp_timer.h> #define GENERAL_TIMER_MAX_EVENTS 10 #define GENERAL_TIMER_MESSAGE 1 #define GENERAL_TIMER_FUNCTION 0 typedef struct { bool used;//是否被添加事件 bool type;//是message 还是 function time_t time; // s, 定时器到达的时间点 // message when type true, or function callback when type false std::string message; void (*func)(void*); void *arg; }TimerEvent; //创建一个类 GeneralTimer class GeneralTimer { public: GeneralTimer();//构造函数，初始化定时器 ~GeneralTimer();//析构函数，清理资源 bool AddTimerEvent(bool type, int time_to_deal, const std::string& message, void (*func)(void*) nullptr, void *arg nullptr); time_t GetNextTime() const { return next_time_; } private: time_t next_time_; esp_timer_handle_t clock_timer_handle_ nullptr; // time_t time_; std::mutex mutex_; }; #endif ``` ## general_timer.cc #### GeneralTimer 类的实现: #### 构造函数和析构函数，以及 AddTimerEvent 方法 ##### 构造函数 ```c++ GeneralTimer::GeneralTimer(void) { // time_ time(NULL) esp_timer_create_args_t clock_timer_args { .callback timer_deal_func, .arg this, .dispatch_method ESP_TIMER_TASK, .name \"GeneralTimer\", .skip_unhandled_events true }; esp_timer_create(&clock_timer_args, &clock_timer_handle_); esp_timer_start_periodic(clock_timer_handle_, 1000000); // 1s } ``` ##### 构造函数 ```c++ GeneralTimer::~GeneralTimer(void) { if (clock_timer_handle_ ! nullptr) { esp_timer_stop(clock_timer_handle_); esp_timer_delete(clock_timer_handle_); } } ``` ##### AddTimerEvent 遍历定时器事件数组，找到第一个未使用的槽位 标记为已使用，填充所有事件信息 计算触发时间：当前时间 + 延迟时间 ```c++ bool GeneralTimer::AddTimerEvent(bool type, int time_to_deal, const std::string& message, void (*func)(void*), void *arg){ std::lock_guard<std::mutex> lock(mutex_); time_t time_ time(NULL); int i; //遍历定时器事件数组，找到第一个未使用的槽位 //标记为已使用，填充所有事件信息 //计算触发时间：当前时间 + 延迟时间 for(i 0;i<GENERAL_TIMER_MAX_EVENTS;i++){ if(!timer_events[i].used){ timer_events[i].used true; timer_events[i].type type; timer_events[i].time time_ + time_to_deal; timer_events[i].message message; timer_events[i].func func; timer_events[i].arg arg; break; } } if(i GENERAL_TIMER_MAX_EVENTS){ //没有空闲槽位，添加失败 return false; } time_t temp timer_events[i].time; for(i 0;i<GENERAL_TIMER_MAX_EVENTS;i++){ if(timer_events[i].time<temp && timer_events[i].used){ temp timer_events[i].time; } } next_time_ temp; return true; } ``` ##### timer_deal_func ``` 硬件定时器每秒触发 ↓ 获取当前时间 + 获取下一个事件时间 ↓ 是否到达下一事件时间？ ├─ 否 → 直接返回（优化） └─ 是 → 遍历所有事件 ↓ 对每个已使用的事件检查 ↓ 时间是否到达？ ├─ 否 → 继续检查下一个 └─ 是 → 执行事件（打印或回调） ↓ 清理槽位（标记为未使用） ``` ```c++ void timer_deal_func(void* arg){ GeneralTimer* timer (GeneralTimer*)arg; time_t current_time time(NULL); if(current_time < timer >GetNextTime()){ return; } for(int i 0;i<GENERAL_TIMER_MAX_EVENTS;i++){ if(timer_events[i].used){ if(current_time > timer_events[i].time){ // deal event if(timer_events[i].type){ // type true, print message printf(\"Timer Event: %s\\n\", timer_events[i].message.c_str()); }else{ // type false, call function callback if(timer_events[i].func ! nullptr){ timer_events[i].func(timer_events[i].arg); } } // mark event as unused timer_events[i].used false; } } } } ``` ## application.h ```c++ #include \"qin_custom/general_timer.h\" public: GeneralTimer *general_timer_ nullptr; ``` ## application.cc ```c++ void Application::Start() { \tgeneral_timer_ new GeneralTimer(); \tconst std::string timer_str \"Application::OnGeneralTimerMessage\"; } ``` ## mcp_server.cc ```c++ AddTool(\"self.add_timer_event\", \"Add a timer event that will trigger after a specified time. seconds\\n\", PropertyList({ Property(\"seconds\", kPropertyTypeInteger), Property(\"message\", kPropertyTypeString) }), [](const PropertyList& properties) > ReturnValue { int time_seconds properties[\"seconds\"].value<int>(); std::string message_ properties[\"message\"].value<std::string>(); auto& app Application::GetInstance(); if (app.general_timer_ ! nullptr) { app.general_timer_ >AddTimerEvent(GENERAL_TIMER_MESSAGE, time_seconds, message_); } return true; }); ```"}}